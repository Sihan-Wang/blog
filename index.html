<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sihan-wang.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="DarcyCAPU&#39;s Blog">
<meta property="og:url" content="https://sihan-wang.github.io/blog/index.html">
<meta property="og:site_name" content="DarcyCAPU&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sihan Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sihan-wang.github.io/blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>DarcyCAPU's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DarcyCAPU's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sihan-wang.github.io/blog/2020/12/14/ConcurrentHashMap-in-JDK1-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Sihan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarcyCAPU's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/12/14/ConcurrentHashMap-in-JDK1-8/" class="post-title-link" itemprop="url">ConcurrentHashMap in JDK1.8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-14 23:44:54 / Modified: 23:45:22" itemprop="dateCreated datePublished" datetime="2020-12-14T23:44:54+08:00">2020-12-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="put-Method"><a href="#put-Method" class="headerlink" title="put Method"></a>put Method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	<span class="comment">// spread:  (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS // 0x7fffffff</span></span><br><span class="line">	<span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">	<span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">		Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">		<span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">			tab = initTable();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">						 <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">				<span class="comment">// tabAt, casTabAt都用到了Unsafe操作。如果cas返回false，（可能是其他线程已经对这个位置进行了set）就会进入for的下一次循环，这时候前一个if就会是false</span></span><br><span class="line">				<span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// -1，也就是表明其他线程在对这个ConcurrentHashMap进行扩容，那么这个线程就帮助其他线程扩容</span></span><br><span class="line">			tab = helpTransfer(tab, f);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			V oldVal = <span class="keyword">null</span>;</span><br><span class="line">			<span class="comment">// 对桶加锁</span></span><br><span class="line">			<span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">				<span class="comment">// 加锁后再检查</span></span><br><span class="line">				<span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">					<span class="comment">// fh &gt;=0 哈希值&gt;=0 是链表的情况</span></span><br><span class="line">					<span class="comment">// 因为TreeBin的哈希值是&lt;0的，因为在TreeBin的构造函数TreeBin(TreeNode&lt;K,V&gt; b) &#123; super(TREEBIN, null, null); .. &#125; super()父类Node构造函数第一个参数是node.hash。TREEBIN是常数-2</span></span><br><span class="line">					<span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">						binCount = <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">							K ek;</span><br><span class="line">							<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">								((ek = e.key) == key ||</span><br><span class="line">								 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">								oldVal = e.val;</span><br><span class="line">								<span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">									e.val = value;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							Node&lt;K,V&gt; pred = e;</span><br><span class="line">							<span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">								<span class="comment">// 尾插法</span></span><br><span class="line">								pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">														  value, <span class="keyword">null</span>);</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">						Node&lt;K,V&gt; p;</span><br><span class="line">						binCount = <span class="number">2</span>;</span><br><span class="line">						<span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">													   value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">							oldVal = p.val;</span><br><span class="line">							<span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">								p.val = value;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">					<span class="comment">// 树化操作在上面的synchronized外面，在树化的过程中重新加锁，将两个操作分离开来</span></span><br><span class="line">					treeifyBin(tab, i);</span><br><span class="line">				<span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">					<span class="keyword">return</span> oldVal;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">	<span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">			tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">					TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">					<span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">						<span class="comment">// 将链表改成双向链表</span></span><br><span class="line">						TreeNode&lt;K,V&gt; p =</span><br><span class="line">							<span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">											  <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">						<span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">							hd = p;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">							tl.next = p;</span><br><span class="line">						tl = p;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 在new TreeBin构造方法中生成了一棵红黑树</span></span><br><span class="line">					setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeBin的构造函数，是与HashMap类似的红黑树插入操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">	<span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">this</span>.first = b;</span><br><span class="line">	TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">		next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">		x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">			x.parent = <span class="keyword">null</span>;</span><br><span class="line">			x.red = <span class="keyword">false</span>;</span><br><span class="line">			r = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			K k = x.key;</span><br><span class="line">			<span class="keyword">int</span> h = x.hash;</span><br><span class="line">			Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">				<span class="keyword">int</span> dir, ph;</span><br><span class="line">				K pk = p.key;</span><br><span class="line">				<span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">					dir = -<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">					dir = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">						 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">					dir = tieBreakOrder(k, pk);</span><br><span class="line">				TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">				<span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">					x.parent = xp;</span><br><span class="line">					<span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">						xp.left = x;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						xp.right = x;</span><br><span class="line">					r = balanceInsertion(r, x);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.root = r;</span><br><span class="line">	<span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么需要使用TreeBin？<br>因为加锁的对象是table[index]，如果还是像HashMap里的那样是一个TreeNode，那么可能因为红黑树的左旋右旋使红黑树的根节点变化，HashMap会使用moveRootToFront方法将root移动到链表的最前面。其他线程如果在这之前尝试对table[index]加锁是可以获取到锁的。使用TreeBin的话就是对整个TreeBin加锁，如果root有变化就更新在TreeBin的root字段即可。<br>是一个很牛逼的思路！！</p>
<p>下面来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">	tab = initTable();</span><br></pre></td></tr></table></figure>

<p>这段代码中的初始化table</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">	<span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>) <span class="comment">// sizeCtl默认情况下是0</span></span><br><span class="line">			Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123; <span class="comment">// 尝试对sizeCtl置为-1（SIZECTL是sizeCtl的offset）。如果有两个线程尝试进行初始化，那么只有一个线程会去做初始化，将sizeCtl置为-1，则另一个线程会在(sc=sizeCtl)&lt;0这个if上spin（sizeCtl是volatile的），让出cpu的使用权</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">					<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">					Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">					table = tab = nt;</span><br><span class="line">					sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// sc = 0.75*n</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				sizeCtl = sc;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addCount(): 控制size+1并保证并发安全；包含了启动扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">	CounterCell[] cs; <span class="keyword">long</span> b, s;</span><br><span class="line">	<span class="keyword">if</span> ((cs = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">		!U.compareAndSetLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">		<span class="comment">// 如果cas失败就进入以下：</span></span><br><span class="line">		CounterCell c; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">		<span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (cs == <span class="keyword">null</span> || (m = cs.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">			<span class="comment">// 每个线程生成一个随机数，得到一个数组的下标</span></span><br><span class="line">			(c = cs[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">			<span class="comment">// cas操作，将c的value+1（put()调用的时候x=1L）</span></span><br><span class="line">			!(uncontended =</span><br><span class="line">			  U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))) &#123;</span><br><span class="line">			<span class="comment">// 如果数组是空的，或生成的下标对应的counterCell元素为空，或者cas操作失败，就进入fullAddCount，可以保证在counterCell里或basecount里完成+1</span></span><br><span class="line">			fullAddCount(x, uncontended);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// sumCount()统计的是baseCount和所有counterCells中的元素</span></span><br><span class="line">		s = sumCount();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ConcurrentHashMap的扩容</span></span><br><span class="line">	<span class="comment">// 在1.7中是支持多线程扩容的，只要线程对应的不同的Segment</span></span><br><span class="line">	<span class="comment">// 这一部分的讨论见fullAddCount之后</span></span><br><span class="line">	<span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">		<span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">			   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">			<span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">			<span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">					sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">					transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">					transfer(tab, nt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">										 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">				transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">			s = sumCount();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>着重看一下fullAddCount<br>是从addCount调用而来的，先默认x=1，wasUncontended=false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123; <span class="comment">// 这个方法是不会随着每个线程的调用而改变的</span></span><br><span class="line">		ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">		h = ThreadLocalRandom.getProbe();</span><br><span class="line">		wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		CounterCell[] cs; CounterCell c; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">		<span class="keyword">if</span> ((cs = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = cs.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 根据后面对counterCells的初始化，cunterCells的长度是2，并且其中一个是null，一个不是null。这里就是对得到的cell是null的情况下进行初始化（counterCells会扩容）</span></span><br><span class="line">			<span class="keyword">if</span> ((c = cs[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果选中的是null的情况：</span></span><br><span class="line">				<span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">					CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">					<span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">						U.compareAndSetInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;  <span class="comment">// cellsBusy改成忙碌</span></span><br><span class="line">						<span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">						<span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">							CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">							<span class="comment">// 改完标记后再判断一次，如果仍然是空的，就把new好的r放到rs也就是counterCells中</span></span><br><span class="line">							<span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">								(m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">								rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">								rs[j] = r;</span><br><span class="line">								created = <span class="keyword">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">							cellsBusy = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (created)</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						<span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				collide = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 以下的else、if都是在选中的cell不是空的情况下</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">				<span class="comment">// wasUncontended=false，这是在外面addCount中尝试对cell进行+1的cas操作时失败了，下面将它改成true，并生成一个新的hash随机数，在下一轮循环中尝试去改另一个cell，可能选中了一个null的cell，就进入上面的if</span></span><br><span class="line">				wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">			<span class="comment">// 接上一个if，如果选中的仍然是之前hash随机数对应的cell，就再次尝试cas+1</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// 如果cas操作还是失败，</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (counterCells != cs || n &gt;= NCPU)</span><br><span class="line">				collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">				collide = <span class="keyword">true</span>;</span><br><span class="line">			<span class="comment">// 要进入下面这个if 分支，collide=true，数组会进行扩容</span></span><br><span class="line">			<span class="comment">// collide=true的条件是上一个elseif中collide是false，并计算一个新的hash随机数。进入到下一次的循环，并一路跳过前面的if-else，来到下面这个if。这样的条件是：不进入上面第一个大if，因为它最后会重置collide为false（这一步的条件是两次循环选中的cell都不是null）；两次对cellValue的cas操作都失败；不进入上面else if (counterCells != cs || n &gt;= NCPU) 这一部分，（这一步的条件是数组已经发生变化[也就是其他线程已经进行了扩容]，counterCells数组大小小于cpu核心数）</span></span><br><span class="line">			<span class="comment">// 那么，可喜可贺，counterCells数组终于可以扩容了！！把热点分散（不是counterCells的两个位置都在忙，而是两次循环都hit到了一个cell，并且cas操作加不成功，就通过扩容把热点分散）</span></span><br><span class="line">			<span class="comment">// 这个扩容仍然是有限制的，也就是counterCell数组长度比NCPU的时候一定不会进行扩容</span></span><br><span class="line">			<span class="comment">// 写出这段代码的真的是巨佬！</span></span><br><span class="line">			<span class="comment">// 需要在cellsBusy为0，并cas操作将其变为1</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">					 U.compareAndSetInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (counterCells == cs) <span class="comment">// Expand table unless stale</span></span><br><span class="line">						counterCells = Arrays.copyOf(cs, n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					cellsBusy = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				collide = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 本线程重新得到一个新的随机数</span></span><br><span class="line">			h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// else部分：如果counterCell数组是空的</span></span><br><span class="line">		<span class="comment">// cellsBusy表示是否有其他线程在使用</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == cs &amp;&amp;</span><br><span class="line">				 <span class="comment">// cas操作将cellsBusy设置成1</span></span><br><span class="line">				 U.compareAndSetInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="comment">// 如果cas操作成功</span></span><br><span class="line">			<span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">				<span class="keyword">if</span> (counterCells == cs) &#123;</span><br><span class="line">					<span class="comment">// 初始化大小为2并随机地放到一个位置</span></span><br><span class="line">					CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>]; </span><br><span class="line">					rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">					counterCells = rs;</span><br><span class="line">					init = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				cellsBusy = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (init)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果有两个线程尝试对counterCell进行初始化，其中一个cas操作失败的线程就尝试对basecount+x</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">			<span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap的扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// ConcurrentHashMap的扩容</span></span><br><span class="line">	<span class="comment">// 在1.7中是支持多线程扩容的，只要线程对应的不同的Segment</span></span><br><span class="line">	<span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">		<span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">			   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">			<span class="comment">// 根据resizeStamp的注释，这个返回的rs 左移 RESIZE_STAMP_SHIFT的时候得到的一定是一个负数（应该是一个很大的负数）</span></span><br><span class="line">			<span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">			<span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">					sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">					transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">					transfer(tab, nt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2根据前面的讨论是&lt;0的，也就是说只有一个线程能把sc设置成负数，其他线程就会在下一次循环的时候进入上面的if(sc&lt;0)的部分。</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">										 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">				transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">			s = sumCount();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来看transfer方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">	<span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)  <span class="comment">// 计算步长，最小设置为16</span></span><br><span class="line">		stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">	<span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">			Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">			nextTab = nt;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">			sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nextTable = nextTab;</span><br><span class="line">		transferIndex = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">	<span class="comment">// ForwardingNode的构造方法，默认将Node的hash设置为MOVED，即-1</span></span><br><span class="line">	<span class="comment">// 就对应了putVal()方法中通过判断if ((fh = f.hash) == MOVED)，可知其他线程在对数组进行扩容。</span></span><br><span class="line">	ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">	<span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">		Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">		<span class="keyword">while</span> (advance) &#123;</span><br><span class="line">			<span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">			<span class="comment">// --i其实在这个while后面的代码逻辑执行完后，在table上往前移一格，如果还比bound大就跳出while继续做转移</span></span><br><span class="line">			<span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">				advance = <span class="keyword">false</span>;</span><br><span class="line">			<span class="comment">// transferIndex表示我现在要转移的部分的最右边的下标+1</span></span><br><span class="line">			<span class="comment">// &lt;=0 说明已经table全部转移完成，于是i=-1并退出while</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				i = -<span class="number">1</span>;</span><br><span class="line">				advance = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// cas操作，把transferIndex设置为nextIndex-stride</span></span><br><span class="line">			<span class="comment">// 如果有两个线程同时到了这里，因为cas操作，通过transferIndex控制，只有一个线程能修改成功，advance仍然为true，继续循环</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt</span><br><span class="line">					 (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">					  nextBound = (nextIndex &gt; stride ?</span><br><span class="line">								   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">				bound = nextBound;</span><br><span class="line">				i = nextIndex - <span class="number">1</span>;</span><br><span class="line">				advance = <span class="keyword">false</span>;</span><br><span class="line">				<span class="comment">// 这里算出来的bound和i就是当前线程需要负责的桶的范围[bound,i]</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前线程已经转移完成或发现已经转移完成</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">			<span class="keyword">int</span> sc;</span><br><span class="line">			<span class="comment">// 默认情况下finishing是false，在下一个if中修改成true后在下个循环中进入到这里</span></span><br><span class="line">			<span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">				<span class="comment">// 终于转移完成了！把table设置成nextTab，新的sizeCtl=2*oldsizeCtl = 2*(0.75*n)</span></span><br><span class="line">				nextTable = <span class="keyword">null</span>;</span><br><span class="line">				table = nextTab;</span><br><span class="line">				sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 在进入转移之前，我们会将sizeCtl修改成 (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2，在helpTransfer中，这些“帮助”线程进入transfer之前会将（已经被最先进来的“主要”线程修改成了上面的值）sizeCtl设置成sizeCtl+1（可能会加好几个1）</span></span><br><span class="line">			<span class="comment">// 那么这里对 sizeCtl进行-1</span></span><br><span class="line">			<span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="comment">// 如果sizeCtl - 2 == (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) 就说明现在只剩下一个线程在transfer函数里，finishing=true，i=n，在下一个循环里进入上面的这个if(finishing)；否则，如果不等于，这些线程就退出transfer函数</span></span><br><span class="line">				<span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">				i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果tab[i]==null, 就设置为fwd</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>) </span><br><span class="line">			advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">		<span class="comment">// 如果tab[i]也是fwd节点，就继续前进</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">			advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 加锁，如果其他线程做put访问到一个fwd的时候会去调用helptransfer，访问到同一个f的时候因为这里加了锁，需要等待。</span></span><br><span class="line">			<span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">					Node&lt;K,V&gt; ln, hn;</span><br><span class="line">					<span class="comment">// 转移链表</span></span><br><span class="line">					<span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">// 与1.7的ConcurrentHashMap链表转移有类似</span></span><br><span class="line">						<span class="comment">// fh &amp; n有两种结果，一种是=0，一种!=0，=0的在newTab里仍在i处，!=0的在i+n处。下面这一段是为了得到最后一段&amp;n结果相同的一串节点</span></span><br><span class="line">						<span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">						Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">						<span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">							<span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">							<span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">								runBit = b;</span><br><span class="line">								lastRun = p;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">							ln = lastRun;</span><br><span class="line">							hn = <span class="keyword">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							hn = lastRun;</span><br><span class="line">							ln = <span class="keyword">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">							<span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">							<span class="comment">// 可以看出这里还是头插法，得到的除了最后那一段，剩下的与原有的链表顺序相反</span></span><br><span class="line">							<span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">								ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 转移到newTab，并将tab[i]设为fwd</span></span><br><span class="line">						setTabAt(nextTab, i, ln);</span><br><span class="line">						setTabAt(nextTab, i + n, hn);</span><br><span class="line">						setTabAt(tab, i, fwd);</span><br><span class="line">						advance = <span class="keyword">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">						TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">						TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">						TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">						<span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">							<span class="keyword">int</span> h = e.hash;</span><br><span class="line">							TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">								(h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">							<span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">								<span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">									lo = p;</span><br><span class="line">								<span class="keyword">else</span></span><br><span class="line">									loTail.next = p;</span><br><span class="line">								loTail = p;</span><br><span class="line">								++lc;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> &#123;</span><br><span class="line">								<span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">									hi = p;</span><br><span class="line">								<span class="keyword">else</span></span><br><span class="line">									hiTail.next = p;</span><br><span class="line">								hiTail = p;</span><br><span class="line">								++hc;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">							(hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">						hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">							(lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">						setTabAt(nextTab, i, ln);</span><br><span class="line">						setTabAt(nextTab, i + n, hn);</span><br><span class="line">						setTabAt(tab, i, fwd);</span><br><span class="line">						advance = <span class="keyword">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下helpTransfer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">	Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">	<span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">		(nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">		<span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">			   (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">				sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">				transfer(tab, nextTab);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nextTab;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sihan-wang.github.io/blog/2020/12/14/HashMap-in-JDK1-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Sihan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarcyCAPU's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/12/14/HashMap-in-JDK1-8/" class="post-title-link" itemprop="url">HashMap in JDK1.8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-14 23:43:45 / Modified: 23:44:39" itemprop="dateCreated datePublished" datetime="2020-12-14T23:43:45+08:00">2020-12-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HashMap中红黑树插入的逻辑"><a href="#HashMap中红黑树插入的逻辑" class="headerlink" title="HashMap中红黑树插入的逻辑"></a>HashMap中红黑树插入的逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">											TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">	x.red = <span class="keyword">true</span>; <span class="comment">// 默认插入节点是红色</span></span><br><span class="line">	<span class="comment">// xp是x的父节点，xpp是x的祖父节点，xppl的xpp的左孩子节点，xppr是xpp的右孩子节点</span></span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">// x是根节点</span></span><br><span class="line">			x.red = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">return</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 父节点是黑色的，或不存在祖父节点，不需要调整</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> root;</span><br><span class="line">		<span class="comment">// 父节点是祖父节点的左孩子</span></span><br><span class="line">		<span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">			<span class="comment">// 叔叔节点不为空，且为红色</span></span><br><span class="line">			<span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">				<span class="comment">// 父节点、叔叔节点变成黑色，祖父节点变成红色</span></span><br><span class="line">				<span class="comment">// 指针定到祖父节点</span></span><br><span class="line">				xppr.red = <span class="keyword">false</span>;</span><br><span class="line">				xp.red = <span class="keyword">false</span>;</span><br><span class="line">				xpp.red = <span class="keyword">true</span>;</span><br><span class="line">				x = xpp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 叔叔节点是空的，或是黑色的</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">					<span class="comment">// 当前节点是右子树，以父节点左旋</span></span><br><span class="line">					root = rotateLeft(root, x = xp);</span><br><span class="line">					xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">					<span class="comment">// x变为x的父节点，也就是左旋下去的节点</span></span><br><span class="line">					<span class="comment">// x和x的父节点都是红色，且x在左子树，必定再需要一次右旋，所以这个if后面不是else</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 当前节点是左子树，则其父节点变为黑色，祖父节点变为红色，祖父节点右旋</span></span><br><span class="line">					xp.red = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">						xpp.red = <span class="keyword">true</span>;</span><br><span class="line">						root = rotateRight(root, xpp);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">				xppl.red = <span class="keyword">false</span>;</span><br><span class="line">				xp.red = <span class="keyword">false</span>;</span><br><span class="line">				xpp.red = <span class="keyword">true</span>;</span><br><span class="line">				x = xpp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">					root = rotateRight(root, x = xp);</span><br><span class="line">					xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">					xp.red = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">						xpp.red = <span class="keyword">true</span>;</span><br><span class="line">						root = rotateLeft(root, xpp);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="put-Method"><a href="#put-Method" class="headerlink" title="put Method"></a>put Method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 调用putVal方法</span></span><br><span class="line">	<span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">	<span class="comment">// 即高位16位不变，低位16位与高位16位进行亦或运算(高位传递到低位)。没有像1.7中的那么复杂，也是因为红黑树的加入，不需要hashcode那么散列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">	<span class="comment">// 把table赋值给tab，table的长度赋值给n</span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// 如果tab为null或者长度为0，则调用resize方法</span></span><br><span class="line">		<span class="comment">// 返回初始化后的节点数组，赋值给tab，同时table的长度赋值给n</span></span><br><span class="line">		n = (tab = resize()).length;</span><br><span class="line">	<span class="comment">// 获取index：(table.length-1) &amp; hash</span></span><br><span class="line">	<span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">		tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Node&lt;K,V&gt; e; K k;</span><br><span class="line">		<span class="comment">// 下面的代码目的是找到在p这个桶下，hash和key对应的已经存在的那个节点，赋值给e</span></span><br><span class="line">		<span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">			<span class="comment">// p这个桶中只有一个节点，把p的key赋值给k</span></span><br><span class="line">			((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			e = p;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">			<span class="comment">// 如果p是TreeNode，调用putTreeVal方法，将返回值赋给e</span></span><br><span class="line">			e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 如果为null，说明链表到头，构造新节点设置给p.next，说明是尾插法</span></span><br><span class="line">					p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">					<span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">						<span class="comment">// TREEIFY_THRESHOLD = 8，这里表示（加入新节点前的）链表长度&gt;=8的时候就需要树化</span></span><br><span class="line">						treeifyBin(tab, hash);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">					((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">// 将e赋给p，即p=p.next</span></span><br><span class="line">				p = e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 这种情况不是新增节点，而是对已经存在节点进行修改</span></span><br><span class="line">			V oldValue = e.value;</span><br><span class="line">			<span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">				e.value = value;</span><br><span class="line">			afterNodeAccess(e); <span class="comment">// 是空方法</span></span><br><span class="line">			<span class="keyword">return</span> oldValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	++modCount;</span><br><span class="line">	<span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">		resize();</span><br><span class="line">	afterNodeInsertion(evict); <span class="comment">// 是空方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们逐一看putTreeVal(), treeifyBin(), resize()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">							   <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">	TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">		<span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">		<span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">			dir = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">			dir = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		<span class="comment">// 如果hash相同，key不同</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">				  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">				 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">				TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">				searched = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">// 对left和right调用find方法，如果找到了，返回对应节点</span></span><br><span class="line">				<span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">					 (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">					((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">					 (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">					<span class="keyword">return</span> q;</span><br><span class="line">			&#125;</span><br><span class="line">			dir = tieBreakOrder(k, pk);</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">		<span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">			Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">			TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">			<span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">				xp.left = x;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				xp.right = x;</span><br><span class="line">			xp.next = x;</span><br><span class="line">			x.parent = x.prev = xp;</span><br><span class="line">			<span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">				((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">			moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="comment">// 如果tab为null或者tab.length &lt; MIN_TREEIFY_CAPACITY=64，数组长度还不那么大的情况下进行扩容，不进行树化桶，通过缩短链表</span></span><br><span class="line">	<span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">		resize();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="comment">// 转变成TreeNode。TreeNode中有prev，其父类Node有next--&gt;双向链表</span></span><br><span class="line">			TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">			<span class="comment">// 这个if-else就表示将原有的链表结构变成了一个双向链表</span></span><br><span class="line">			<span class="comment">// 并在循环结束的时候hd是头结点，tl是尾结点</span></span><br><span class="line">			<span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">				hd = p;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				p.prev = tl;</span><br><span class="line">				tl.next = p;</span><br><span class="line">			&#125;</span><br><span class="line">			tl = p;</span><br><span class="line">		&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">// 将root节点hd赋值给tab[index]</span></span><br><span class="line">		<span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">			<span class="comment">//转换为TreeNode节点后，进行树化</span></span><br><span class="line">			hd.treeify(tab);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是TreeNode的方法</span></span><br><span class="line"><span class="comment">// 遍历双向链表，转化成红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">	TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">		next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">		x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// x设置给root，颜色设成黑色</span></span><br><span class="line">			x.parent = <span class="keyword">null</span>;</span><br><span class="line">			x.red = <span class="keyword">false</span>;</span><br><span class="line">			root = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			K k = x.key;</span><br><span class="line">			<span class="keyword">int</span> h = x.hash;</span><br><span class="line">			Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">			<span class="comment">// 从根节点开始</span></span><br><span class="line">			<span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">				<span class="keyword">int</span> dir, ph;</span><br><span class="line">				K pk = p.key;</span><br><span class="line">				<span class="comment">// 比较p的hash值和新节点的hash值</span></span><br><span class="line">				<span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">					dir = -<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">					dir = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">						 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">					<span class="comment">// comparableClassFor(k): 如果k的Class实现了Comparable&lt;C&gt;接口，就返回k.class，否则返回null</span></span><br><span class="line">					<span class="comment">// compareComparables，返回k.compareTo(x)</span></span><br><span class="line">					<span class="comment">// 如果哈希值相同，compareTo返回也相同，就调用tieBreakOrder方法，会比较p和pk的class的名字，如果还相等就比较System.identityHashCode()，返回的是系统做的哈希值，因为用户可能重写hashCode()</span></span><br><span class="line">					dir = tieBreakOrder(k, pk);</span><br><span class="line">				TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">				<span class="comment">// dir&lt;=0 then p = p.left else p = p.right</span></span><br><span class="line">				<span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 插入到红黑树中，再调整红黑树</span></span><br><span class="line">					x.parent = xp;</span><br><span class="line">					<span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">						xp.left = x;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						xp.right = x;</span><br><span class="line">					<span class="comment">// 将x节点插入到红黑树中</span></span><br><span class="line">					root = balanceInsertion(root, x);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">		TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">		<span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">			<span class="comment">// 虽然转换形成了红黑树，原来双向链表的prev和next指针都还在，这里要把root在双向链表中移到最前面去</span></span><br><span class="line">			Node&lt;K,V&gt; rn;</span><br><span class="line">			<span class="comment">// 将root赋值给tab[index] （原来是first）</span></span><br><span class="line">			tab[index] = root;</span><br><span class="line">			TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">			<span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">				((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">			<span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">				rp.next = rn;</span><br><span class="line">			<span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">				first.prev = root;</span><br><span class="line">			root.next = first;</span><br><span class="line">			root.prev = <span class="keyword">null</span>;</span><br><span class="line">			<span class="comment">// 即原来  tab[i]: first         某个位置： root.prev root  root.next</span></span><br><span class="line">			<span class="comment">// 现在    tab[i]: root  first   某个位置： root.prev  root.next</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在put()方法中：if (++size &gt; threshold) resize(); 扩容条件与1.7不同：if(size&gt;=threshold &amp;&amp; (null != table[bucketIndex]))</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">	Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">	<span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">	<span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">	<span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 这个if做的是 设置好newCap和newThr</span></span><br><span class="line">	<span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果oldCap&gt;0,说明是扩容（*2）的情况</span></span><br><span class="line">		<span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">			threshold = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">return</span> oldTab;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将oldCap &lt;&lt; 1 赋值给newCap</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; <span class="comment">// 1&lt;&lt;30</span></span><br><span class="line">				 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">// 16</span></span><br><span class="line">			newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 到这里说明是哈希表新建的情况</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 这个情况下说明用的是有参构造函数，threshold被初始化为tablesizefor(initialCapacity), 是&gt;=initialCapacity的2的幂次（*）</span></span><br><span class="line">		newCap = oldThr;</span><br><span class="line">	<span class="keyword">else</span> &#123;  <span class="comment">// 说明用的是无参构造函数</span></span><br><span class="line">		newCap = DEFAULT_INITIAL_CAPACITY;    <span class="comment">// 16</span></span><br><span class="line">		newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);   <span class="comment">// 12</span></span><br><span class="line">	&#125;       </span><br><span class="line">	<span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 是前面（*）的情况，或者是nexCap&gt;=MAXIMUM_CAPACITY, oldCap &lt; 16</span></span><br><span class="line">		<span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">		newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">				  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	threshold = newThr;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">		Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">	<span class="comment">// 将newTab赋值给table</span></span><br><span class="line">	table = newTab;</span><br><span class="line">	<span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// oldTab != null，是扩容状态，对旧表的数据向新表迁移</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">			Node&lt;K,V&gt; e;</span><br><span class="line">			<span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果e不为null，则迁移，将旧表清空</span></span><br><span class="line">				oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">					<span class="comment">// 如果只有一个节点，新的index为  e.hash &amp; (newCap - 1)</span></span><br><span class="line">					newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">					<span class="comment">// 如果e是TreeNode，调用e的split方法进行重新分配</span></span><br><span class="line">					((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">				<span class="keyword">else</span> &#123; </span><br><span class="line">					<span class="comment">// 为链表，转移链表元素</span></span><br><span class="line">					Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">					Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">					Node&lt;K,V&gt; next;</span><br><span class="line">					<span class="keyword">do</span> &#123;</span><br><span class="line">						<span class="comment">// 将e.next赋值给next</span></span><br><span class="line">						next = e.next;</span><br><span class="line">						<span class="comment">// oldCap=1000，newCap=10000</span></span><br><span class="line">						<span class="comment">// hash &amp; oldCap = has &amp; 1000, 要么等于0， 要么不等于0</span></span><br><span class="line">						<span class="comment">// 如果结果为0，hash为0xxx，说明 hash &amp; 1111=hash &amp; 0111，还是在原来的桶的index下</span></span><br><span class="line">						<span class="comment">// 如果结果不为0，hash为1xxx，转移到原来桶的index + oldCap 的新桶中</span></span><br><span class="line">						<span class="comment">// 对放到两个新桶中的 组建两个链表lo和hi，每次不断将e放到tail.next</span></span><br><span class="line">						<span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">							<span class="comment">//(e.hash &amp; oldCap) == 0，说明还是在原来的桶</span></span><br><span class="line">							<span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">								loHead = e;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								loTail.next = e;</span><br><span class="line">							loTail = e;</span><br><span class="line">							<span class="comment">// newTab[j] = loHead;</span></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="comment">// 说明在另一个桶</span></span><br><span class="line">							<span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">								hiHead = e;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								hiTail.next = e;</span><br><span class="line">							hiTail = e;</span><br><span class="line">						 	<span class="comment">// newTab[j + oldCap] = hiHead;   </span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">					<span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">						loTail.next = <span class="keyword">null</span>;</span><br><span class="line">						newTab[j] = loHead;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">						hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">						newTab[j + oldCap] = hiHead;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只剩下了TreeNode的split方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">	TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">	<span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">	TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">	TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span></span><br><span class="line">	<span class="comment">// 设置e为b，也就是this，也就是树桶的第一个节点root，对其进行链表的遍历</span></span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">		next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">		e.next = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// bit就是oldCap，二进制位10000</span></span><br><span class="line">		<span class="comment">// 如果hash&amp;bit为0，放在lo的队尾,lc++</span></span><br><span class="line">		<span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">				loHead = e;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				loTail.next = e;</span><br><span class="line">			loTail = e;</span><br><span class="line">			++lc;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果hash&amp;bit为1，放在hi的队尾,hc++</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">				hiHead = e;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				hiTail.next = e;</span><br><span class="line">			hiTail = e;</span><br><span class="line">			++hc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)  <span class="comment">// 6</span></span><br><span class="line">			<span class="comment">// 如果lc&lt;=6，把树改成链表</span></span><br><span class="line">			tab[index] = loHead.untreeify(map);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果lc&gt;6,tab[index] = loHead</span></span><br><span class="line">			tab[index] = loHead;</span><br><span class="line">			<span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">				<span class="comment">// 这里表示loHead存在，hiHead也存在的情况，否则hiHead不存在，就表示低位的链表已经是一个红黑树，就不需要树化了</span></span><br><span class="line">				<span class="comment">// 如果hiHead不为null，树化loHead</span></span><br><span class="line">				loHead.treeify(tab);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">			tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果hc&gt;6,tab[index + bit] = hiHead</span></span><br><span class="line">			tab[index + bit] = hiHead;</span><br><span class="line">			<span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">				<span class="comment">// 如果loHead不为null，树化hiHead</span></span><br><span class="line">				hiHead.treeify(tab);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">		<span class="comment">// replacementNode: For conversion from TreeNodes to plain nodes, left,right,parent这些都变为null</span></span><br><span class="line">		<span class="comment">// 生成出一个单向链表</span></span><br><span class="line">		Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">			hd = p;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tl.next = p;</span><br><span class="line">		tl = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，put()就完成了！</p>
<h2 id="get-Method"><a href="#get-Method" class="headerlink" title="get Method"></a>get Method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">	<span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">			((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			<span class="keyword">return</span> first;</span><br><span class="line">		<span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 是红黑树节点</span></span><br><span class="line">			<span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				<span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">			<span class="comment">// 是链表节点</span></span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">					((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">					<span class="keyword">return</span> e;</span><br><span class="line">			&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove-Method"><a href="#remove-Method" class="headerlink" title="remove Method"></a>remove Method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">		<span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">						   <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">	<span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		(p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">		<span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">			((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			node = p;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				<span class="comment">// 如果p是TreeNode，getTreeNode(hash, key)</span></span><br><span class="line">				node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">						((k = e.key) == key ||</span><br><span class="line">						 (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">						<span class="comment">// 遍历链表，找到对应的节点e</span></span><br><span class="line">						node = e;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					p = e;</span><br><span class="line">				&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">							 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">			<span class="comment">// 1.8的HashMap提供了matchValue的方式，也就是key和value都相等的时候才remove</span></span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				<span class="comment">// 如果node是TreeNode，调用node的removeTreeNode(this, tab, movable)</span></span><br><span class="line">				((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">				<span class="comment">// 如果node是p，即node是头结点，tab[index] = node.next</span></span><br><span class="line">				tab[index] = node.next;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">// 否则p为node的上一个节点，p.next = node.next</span></span><br><span class="line">				p.next = node.next;</span><br><span class="line">			++modCount;</span><br><span class="line">			--size;</span><br><span class="line">			afterNodeRemoval(node);</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看removeTreeNode中的一个点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">						  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// remove之后可能红黑树太小，需要转成链表，但这里判断方式不是比较节点数&lt;=6</span></span><br><span class="line">	<span class="comment">// 如果root.right==null，root只有左子树，红黑树只有两个节点</span></span><br><span class="line">	<span class="comment">// rl == null, root只有右子树，类似</span></span><br><span class="line">	<span class="comment">// rl.left == null</span></span><br><span class="line">	<span class="comment">// 但六个节点的红黑树不止一种？？</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">		(rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">		tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个问题，为什么需要在8个节点后将链表转换成红黑树<br>我们可以考虑链表的一个Node，包含value和next，红黑树的一个Node包含value，left，right，parent，也就是说红黑树的一个节点需要的空间大概是链表的两倍。<br>下面看时间复杂度。<br>下表表示在最坏情况下，链表和红黑树中搜索一个节点需要的时间</p>
<table>
<thead>
<tr>
<th>链表</th>
<th>红黑树</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>4</td>
</tr>
</tbody></table>
</br>

<p>也就是说在9个节点后，红黑树时间/空间开始优于链表。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sihan-wang.github.io/blog/2020/12/14/ConcurrentHashMap-in-JDK1-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Sihan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarcyCAPU's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/12/14/ConcurrentHashMap-in-JDK1-7/" class="post-title-link" itemprop="url">ConcurrentHashMap in JDK1.7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-14 23:42:10 / Modified: 23:43:22" itemprop="dateCreated datePublished" datetime="2020-12-14T23:42:10+08:00">2020-12-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h3><p>ConcurrentHashMap的Fields：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认的并发级别，是Segment数组的默认长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 每个segment的table最小的capacity，是2的幂次，最小是2是为了避免在lazy construction之后再次使用就需要resize</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 最大的segment数（也就是并发级别）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// slightly conservative</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>Segment的Fields：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The per-segment table</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// The number of elements.</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// The total number of mutative operations in this segment.</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 当size超过threshold时进行rehash。threshold=capacity*loadFactor</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h2 id="Constrctor"><a href="#Constrctor" class="headerlink" title="Constrctor"></a>Constrctor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">						 <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">	<span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">		concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">	<span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">	<span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// segment数组的大小，&gt;=并发级别的一个2的幂次方数</span></span><br><span class="line">	<span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">		++sshift;</span><br><span class="line">		ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">	<span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">		initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">	<span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">	<span class="comment">// 相当于上取整，为了保证segment数组的entry个数足够</span></span><br><span class="line">	<span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">		++c;</span><br><span class="line">	<span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; <span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">		cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// DEFAULT_INITIAL_CAPACITY / DEFAULT_CONCURRENCY_LEVEL = 1</span></span><br><span class="line">	<span class="comment">// 那么默认情况下cap就是2</span></span><br><span class="line">	<span class="comment">// create segments and segments[0]</span></span><br><span class="line">	Segment&lt;K,V&gt; s0 =</span><br><span class="line">		<span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">						 (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">	Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">	<span class="comment">// 把new出来的s0放到ss数组的第0个位置，这样做是为了new Segment数组的具体某一个位置的时候可以直接使用s0已经计算好的一些参数，不用每次都计算（相当于一个原型），具体可见ConcurrentHashMap的put方法</span></span><br><span class="line">	UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">	<span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps.<br>后续的扩容是扩的某一Segment的table数组，Segment数组大小是不变的</p>
<h2 id="UNSAFE"><a href="#UNSAFE" class="headerlink" title="UNSAFE"></a>UNSAFE</h2><p>一个场景，两个线程都对id变量+1，再sleep500ms。这是线程不安全的。出现这个现象的原因是线程对自己缓存的id进行++，而不是对内存中的id</p>
<h3 id="如何获取Unsafe对象？"><a href="#如何获取Unsafe对象？" class="headerlink" title="如何获取Unsafe对象？"></a>如何获取Unsafe对象？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做会报错。在getUnsafe()中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Class var0 = Reflection.getCallerClass();</span><br><span class="line">	<span class="keyword">if</span> (var0.getClassLoader() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> theUnsafe;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap中使用的Unsafe对象的ClassLoader是Bootstrap ClassLoader了，用来加载java的核心库，不继承自java.lang.ClassLoader，返回时是null。<br>我们在Person中这样定义的Unsafe对象的ClassLoader则是Application ClassLoader，用来加载用户类路径CLASSPATH下的类库，返回时不是null。<br>所以我们的代码会抛出异常。<br>我们可以通过反射来获得Unsafe里面的私有成员变量theUnsafe：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> ID_OFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    static &#123;</span></span><br><span class="line"><span class="comment">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Field field = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 获取Person类的id的偏移量</span></span><br><span class="line">            ID_OFFSET = UNSAFE.objectFieldOffset(Person.class.getDeclaredField(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// person.id++;</span></span><br><span class="line">                    <span class="comment">// 四个参数：对象、对象值、期望值和更新值</span></span><br><span class="line">                    <span class="comment">// 判断当前在内存中的person.id是不是当前线程认为的person.id，如果是就+1，操作是原子的</span></span><br><span class="line">                    <span class="keyword">boolean</span> b = UNSAFE.compareAndSwapInt(person, ID_OFFSET, person.id, person.id+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                        System.out.println(UNSAFE.getIntVolatile(person, ID_OFFSET));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// person.id++;</span></span><br><span class="line">                    UNSAFE.compareAndSwapInt(person, ID_OFFSET, person.id, person.id+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">boolean</span> b = UNSAFE.compareAndSwapInt(person, ID_OFFSET, person.id, person.id+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                        System.out.println(UNSAFE.getIntVolatile(person, ID_OFFSET));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码还是有问题的，System.out.println()的时候还是可能出现两个连续的数字。但是加的过程是正确的。</p>
<hr>
<p>用CAS去获取数组的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String[] table;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		<span class="comment">// 数组中存储的对象的对象头的大小</span></span><br><span class="line">		<span class="keyword">int</span> ns = UNSAFE.arrayIndexScale(String[].class);</span><br><span class="line">		<span class="comment">// 数组中第一个元素的起始位置</span></span><br><span class="line">		<span class="keyword">int</span> base = UNSAFE.arrayBaseOffset(String[].class);</span><br><span class="line">		System.out.println(UNSAFE.getObject(Person.class, base+<span class="number">1</span>*ns));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>???</p>
<h2 id="put-Method"><a href="#put-Method" class="headerlink" title="put Method"></a>put Method</h2><p>ConcurrentHashMap:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key，value都不能为null，与jdk1.7的HashMap不一样</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; </span><br><span class="line">	Segment&lt;K,V&gt; s;</span><br><span class="line">	<span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	<span class="keyword">int</span> hash = hash(key);</span><br><span class="line">	<span class="comment">// segmentMask = Segment[].length - 1</span></span><br><span class="line">	<span class="comment">// sshift = log2(ssize) = log2(Segment[].length)</span></span><br><span class="line">	<span class="comment">// segmentShift = 32 - sshift</span></span><br><span class="line">	<span class="comment">// hash &gt;&gt;&gt; segmentShift 表示只取了hash的高sshift位</span></span><br><span class="line">	<span class="comment">// 再去 &amp; (Segment[].length - 1)</span></span><br><span class="line">	<span class="comment">// 有个问题，那这里 &amp; segmentMask 是不是不需要？</span></span><br><span class="line">	<span class="comment">// 在哈希Segment的table的时候是hash值是取低位的，是为了更好的散列性。因为如果Segment[].length == table[].length，很多其他的entry位置是不会被哈希到的，浪费空间降低效率</span></span><br><span class="line">	<span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">	<span class="comment">// SBASE = UNSAFE.arrayBaseOffset(Segment[].class)</span></span><br><span class="line">	<span class="comment">// ss = UNSAFE.arrayIndexScale(Segment[].class)：获取数组中一个元素的大小(get size of an element in the array)</span></span><br><span class="line">	<span class="comment">// SSHIFT = 31 - Integer.numberOfLeadingZeros(ss);</span></span><br><span class="line">	<span class="comment">// 也就是ss的二进制位数-1</span></span><br><span class="line">	<span class="comment">// 所以j&lt;&lt;SHIFT 就是 表示数组的第j个元素</span></span><br><span class="line">	<span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">		 (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">		s = ensureSegment(j);</span><br><span class="line">	<span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">		<span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里k为null的话也是会报错的</span></span><br><span class="line">	h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">	<span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">	h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">	h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">	h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">	h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">	h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">	<span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">	<span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">	Segment&lt;K,V&gt; seg;</span><br><span class="line">	<span class="comment">// 可能有两个线程同时进入了ensureSegment，那么只能有一个线程负责create Segment，另一个线程返回这个生成的Segment。</span></span><br><span class="line">	<span class="comment">// 查看ss的第u个位置是不是空, getObjectVolatile附加了&#x27;volatile&#x27;加载语义</span></span><br><span class="line">	<span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">		Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">		<span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">		<span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">		<span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">		HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">		<span class="comment">// 上面做了一些准备工作，所以这里还需要再判断一下</span></span><br><span class="line">		<span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">			== <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">			Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">			<span class="comment">// while + CAS，自旋操作</span></span><br><span class="line">			<span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">				   == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果这里的if的条件返回是false，说明已经有另一个线程做了把在ss的u位置放上seg的操作。如果上面不用while，这里的if如果返回false，则最终返回的seg就会是null</span></span><br><span class="line">				<span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们看Segment中的put方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">	HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">		scanAndLockForPut(key, hash, value);</span><br><span class="line">	V oldValue;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">		<span class="comment">// 这里表明是用的hash低位</span></span><br><span class="line">		<span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">		HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">		<span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;  <span class="comment">// 这里的操作基本与HashMap的put一样</span></span><br><span class="line">				K k;</span><br><span class="line">				<span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">					(e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">					oldValue = e.value;</span><br><span class="line">					<span class="comment">// 这里的onlyIfAbsent，在ConcurrentHashMap的put方法中，传入的是false，在putIfAbsent中，传入的true，表示如果已经存在key，就什么都不做，返回的是ondValue</span></span><br><span class="line">					<span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">						e.value = value;</span><br><span class="line">						++modCount;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				e = e.next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">					node.setNext(first);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="comment">// 这里HashEntry的最后一个参数是first，表示仍然是头插法，后面setEnryAt就是将插入node的设为链表头</span></span><br><span class="line">					node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">				<span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">					rehash(node);</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					<span class="comment">// 放到table数组上，使用的仍然是Unsafe的方法，如果只写tab[index] = node，修改的只是当前线程里的tab</span></span><br><span class="line">					setEntryAt(tab, index, node);</span><br><span class="line">				++modCount;</span><br><span class="line">				count = c;</span><br><span class="line">				oldValue = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); 中：<br>tryLock()是ReentrantLock的方法，是不阻塞的（与lock()不同），能获取锁就返回true。<br>在while(!tryLock())的过程中是可以做一些事情的，也就是new HashEntry&lt;K,V&gt;(hash, key, value, first); 需要new的条件也就是这个位置的entry为空或者已经遍历到entry的尾部（也就是链表中没有相同的key）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">	HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">	HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">	HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">	<span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">		HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">		<span class="comment">// 尝试去new HashEntry</span></span><br><span class="line">		<span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">					node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">				retries = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">				retries = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				e = e.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">			<span class="comment">// 这里不需要担心在阻塞的时候其他线程改变了链表，因为在当前线程获取到锁后，返回到put()中，first是会重新去获取的，还会set node的next为first，逻辑上是正确的。</span></span><br><span class="line">			lock();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">				 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">			<span class="comment">// retries 是偶数，就是说每隔一次去看一下</span></span><br><span class="line">			<span class="comment">// 没获取到锁，可能其他线程获取到了锁，并头插法改变了链表，所以!=first，就需要重新尝试去new</span></span><br><span class="line">			e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">			retries = -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可能代码上存在一些不是很清楚的逻辑，但这其实就是想说，在自旋的过程中尝试去new HashEntry，在等待lock的时候会做提前一些重复劳动，让while循环慢一点，不要频繁地去尝试获取锁</p>
<hr>
<p>现在put()只剩下了rehash()扩容相关。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">	HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">	<span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">	<span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>; <span class="comment">// 双倍扩容</span></span><br><span class="line">	threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">	HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">		(HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">	<span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">		HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">		<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 等于null当然不需要转移</span></span><br><span class="line">			HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">			<span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">			<span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">				newTable[idx] = e;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">				HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">				<span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">				<span class="comment">// 第一个for，最终得到的lastRun，是最后一段与链表末端节点相同新index的那段链表的第一个节点，得到的lastIdx是这段的新index。</span></span><br><span class="line">				<span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">					 last != <span class="keyword">null</span>;</span><br><span class="line">					 last = last.next) &#123;</span><br><span class="line">					<span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">					<span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">						lastIdx = k;</span><br><span class="line">						lastRun = last;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 把这一段链表放到新的table上去</span></span><br><span class="line">				newTable[lastIdx] = lastRun;</span><br><span class="line">				<span class="comment">// Clone remaining nodes</span></span><br><span class="line">				<span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">					V v = p.value;</span><br><span class="line">					<span class="keyword">int</span> h = p.hash;</span><br><span class="line">					<span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">					HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">					newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 扩容完成后把需要put的node对象放到新的table中去</span></span><br><span class="line">	<span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">	node.setNext(newTable[nodeIndex]);</span><br><span class="line">	newTable[nodeIndex] = node;</span><br><span class="line">	table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-Method"><a href="#get-Method" class="headerlink" title="get Method"></a>get Method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">	HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">	<span class="keyword">int</span> h = hash(key);</span><br><span class="line">	<span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">	<span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">		(tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">				 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">			 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">			K k;</span><br><span class="line">			<span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">				<span class="keyword">return</span> e.value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="size-method"><a href="#size-method" class="headerlink" title="size method"></a>size method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">	<span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">	<span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">	<span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">	<span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">	<span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;  <span class="comment">// =2</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">					ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 在给每个segment加锁之前，以下会循环两次。第一次给last赋值了sum，sum是所有modCount的和，第二次如果发现计算出的sum还是第一次的last，就会直接退出for，并返回size</span></span><br><span class="line">			sum = <span class="number">0L</span>;</span><br><span class="line">			size = <span class="number">0</span>;</span><br><span class="line">			overflow = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">				Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">				<span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">					sum += seg.modCount;</span><br><span class="line">					<span class="keyword">int</span> c = seg.count;</span><br><span class="line">					<span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">						overflow = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (sum == last)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			last = sum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">				segmentAt(segments, j).unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sihan-wang.github.io/blog/2020/12/14/HashMap-in-JDK1-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Sihan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarcyCAPU's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/12/14/HashMap-in-JDK1-7/" class="post-title-link" itemprop="url">HashMap in JDK1.7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-14 23:32:37 / Modified: 23:33:19" itemprop="dateCreated datePublished" datetime="2020-12-14T23:32:37+08:00">2020-12-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line"><span class="comment">/** 最大初始容量，2^30 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">/** 负载因子，默认0.75，负载因子越小，hash冲突机率越低 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?, ?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K, V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="comment">/** HashMap实际存储的元素个数*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">/** HashMap 实际能存储的大小, threshold=capacity*loadFactor */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor:"></a>Constructor:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>;</span><br><span class="line">	<span class="comment">// this.threshold = initialCapacity</span></span><br><span class="line">	<span class="comment">// this.loafFactor = loadFactor</span></span><br></pre></td></tr></table></figure>

<h2 id="Put-Method"><a href="#Put-Method" class="headerlink" title="Put Method:"></a>Put Method:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化HashMap（设置容量、临界值，新的Entry数组引用）</span></span><br><span class="line"><span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">	inflateTable(threshold);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>体现了延迟加载，在真正put的时候才做真正的初始化操作。构造方法中只是做了一些参数的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">	<span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">	threshold = (<span class="keyword">int</span>)Math.min(capacity*loadFactor, MAXIMUM_CAPACITY+<span class="number">1</span>);</span><br><span class="line">	table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">	initHashSeedAsNeeded(capacity); <span class="comment">// 先不关心这个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">		? MAXIMUM_CAPACITY</span><br><span class="line">		: (num&gt;<span class="number">1</span>) ? Integer.highestOneBit((number-<span class="number">1</span>)&lt;&lt;<span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// number-1是为了防止number本身就是8的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Integer.highestOneBit(i) : 返回&lt;=i的2的次方数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	i |= (i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	i |= (i &gt;&gt; <span class="number">2</span>);</span><br><span class="line">	i |= (i &gt;&gt; <span class="number">4</span>);</span><br><span class="line">	i |= (i &gt;&gt; <span class="number">8</span>);</span><br><span class="line">	i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">i=0001 ****</span></span><br><span class="line"><span class="comment">0001 **** | 0000 1*** = 0001 1***</span></span><br><span class="line"><span class="comment">0001 1*** | 0000 011* = 0001 111*</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">i= 0001 1111</span></span><br><span class="line"><span class="comment">0001 1111 - 0000 1111 = 0001 0000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>) </span><br><span class="line">	<span class="keyword">return</span> putForNullKey(value);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若“key为null”，则将该键值对添加到table[0]处，遍历该链表，如果有key为null，则将value替换。没有就创建新Entry对象放在链表表头</span></span><br><span class="line"><span class="comment">// 所以table[0]的位置上，永远最多存储1个Entry对象，形成不了链表。key为null的Entry存在这里</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">			V oldValue = e.value;</span><br><span class="line">			e.value = value;</span><br><span class="line">			e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">			<span class="keyword">return</span> oldValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	modCount++;</span><br><span class="line">	addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// here key != null， 计算key对应的hash值</span></span><br><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h = hashSeed;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		<span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">	&#125;</span><br><span class="line">	h ^= k.hashCode();</span><br><span class="line">	h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">	<span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length); </span><br><span class="line"><span class="comment">// [Method] indexFor(int h, int length):</span></span><br><span class="line"><span class="comment">//	return h &amp; (length-1); 返回值范围[0,length)</span></span><br><span class="line"><span class="comment">// length=2^x, length-1高位都是0，低位都是1，只有hash的高位起了作用</span></span><br><span class="line"><span class="comment">// 如果length太小，冲突会增加，table上对应链表过长，影响get()的效率</span></span><br><span class="line"><span class="comment">// 可以通过扩容来解决，但在hash的运算中，用位运算将hash的高位利用起来:</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">	<span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对table[i]对应的链表进行排序</span></span><br><span class="line"><span class="keyword">for</span>(Entry&lt;K, V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">	Object k;</span><br><span class="line">	<span class="comment">// 如果链表中已经存在key：hash值相同且对象相同</span></span><br><span class="line">	<span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">		V oldValue = e.value;</span><br><span class="line">		e.value = value;</span><br><span class="line">		e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">return</span> oldValue;  <span class="comment">// 返回被新value替换的old value</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改次数+1</span></span><br><span class="line">modCount++;</span><br><span class="line"><span class="comment">// table数组中没有key对应的键值对，就将key-value添加到table[i]处 </span></span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 需要扩容？size表示的是整个HashMap中元素的个数，而不是数组的元素个数 条件为size&gt;=threshold &amp;&amp; table的bucketIndex位置不是空的（如果是空的就没有冲突，不会引发扩容</span></span><br><span class="line">	<span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">		resize(<span class="number">2</span>*table.length);</span><br><span class="line">		hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">		bucketIndex = indexFor(hash, table.length);</span><br><span class="line">	&#125;</span><br><span class="line">	createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">	Entry&lt;K, V&gt; e = table[bucketIndex];</span><br><span class="line">	<span class="comment">// new Entry的最后一个参数表示next entry，也就是把table[bucketIndex]当做了链表的下一个元素，并且new entry插到链表头部</span></span><br><span class="line">	table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">	size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">	Entry[] oldTable = table;</span><br><span class="line">	<span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">	<span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">		threshold = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">	transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">	table = newTable;</span><br><span class="line">	threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">	<span class="keyword">for</span>(Entry&lt;K, V&gt; e: table) &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">			Entry&lt;K, V&gt; next = e.next;</span><br><span class="line">			<span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">				e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">			<span class="comment">// 因为indexFor做的操作是e.hash &amp; (newCapacity-1)</span></span><br><span class="line">			<span class="comment">// 在rehash=false，没有重新计算hash的情况下：</span></span><br><span class="line">			<span class="comment">// hash=1011 0110, capacity=16, newCapacity=2*capacity</span></span><br><span class="line">			<span class="comment">// 1011 0110 &amp; 0000 1111; 1011 0110 &amp; 0001 1111;</span></span><br><span class="line">			<span class="comment">// 所以新的index位置要么不变，要么是原来的index+capacity</span></span><br><span class="line">			<span class="comment">// 也就是把原先的一条链表拆成了两条链表</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 将e插到newTable[i]上</span></span><br><span class="line">			e.next = newTable[i];</span><br><span class="line">			newTable[i] = e;</span><br><span class="line">			e = next;</span><br><span class="line">			<span class="comment">// 这里就体现了使用链表数据结构的一个缺点：扩容之后假设Entry在newTable的index都不变的话，由于每次都是插到链表头，链表会翻转</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一个缺点：在多线程情况下，如果两个线程p1、p2都调用到了transfer，两个线程都会new一个newTable。假设链表是1、2、3，转移到newTable1后还是在同一个index上形成了翻转的链表：3、2、1</span></span><br><span class="line"><span class="comment">// 考虑以下情况：p2运行到Entry&lt;K, V&gt; next = e.next;后挂起，p1执行完了整个while，那么p2的e和next分别指向newTable1[i]的1，2</span></span><br><span class="line"><span class="comment">// p2: e.next = newTable[i]; newTable[i] = e; 结果是newTable1[i]中的1被放到了newTable2[i]，newTable1[i]中的2的next，指向了newTable2[i]的1，随后e2=next2=newTable1[i]的2</span></span><br><span class="line"><span class="comment">// 接下来next2=e2.next=newTable2[i]的1=newTable2[i], e.next=newTable[i]（e2.next本来就等于newTable2[i]），newTable[i]=e，即newTable1[i]中的2倍放到了newTable2[i]上，e=next即e2指向了newTable2[i]的1</span></span><br><span class="line"><span class="comment">// 下一轮的next=e.next，即next2指向了newTable2[i]的1的next，即null，e.next = newTable[i]，即e2（newTable2[i]的1）的next指向了newTable[i],在这里就是2，这时候就出现了循环链表</span></span><br></pre></td></tr></table></figure>

<hr>
<p>想要处理这个线程不安全的问题，一种方法就是给HashMap加一把锁，也就是Hashtable，它的每个public方法上都加了synchronized<br>另一种方法就是给HashMap底层的table每两个Entry加一把锁（分段锁），也就是不能同时操作这两个Entry。效率会比Hashtable高，这就是ConcurrentHashMap的做法</p>
<hr>
<p>我们再看transfer中的rehash，它是resize中的initHashSeedAsNeeded(newCapacity)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// hashSeed初始化为0，并且只在switching=true的时候被修改</span></span><br><span class="line">	<span class="comment">// currentAltHashing 一开始是false</span></span><br><span class="line">	<span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">			(capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">	<span class="comment">// Holder.ALTERNATIVE_HASHING_THRESHOLD</span></span><br><span class="line">	<span class="comment">// 通过查看Holder类可知，Holder.ALTERNATIVE_HASHING_THRESHOLD一般就是等于Integer.MAX_VALUE（默认情况），除非在编译的时候配置了jdk.map.althashing.threshold</span></span><br><span class="line">	<span class="comment">// 所以useAltHashing一般情况下就是false，所以switching=false，也就是说一般是不会做rehash的</span></span><br><span class="line">	<span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">	<span class="keyword">if</span> (switching) &#123;</span><br><span class="line">		hashSeed = useAltHashing</span><br><span class="line">			? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">			: <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="get-Method"><a href="#get-Method" class="headerlink" title="get Method"></a>get Method</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> getForNullKey();</span><br><span class="line">	Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">	<span class="comment">// 遍历table[index]对应的链表</span></span><br><span class="line">	<span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">		 e != <span class="keyword">null</span>;</span><br><span class="line">		 e = e.next) &#123;</span><br><span class="line">		Object k;</span><br><span class="line">		<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">			((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			<span class="keyword">return</span> e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<hr>
<h2 id="其他讨论"><a href="#其他讨论" class="headerlink" title="其他讨论"></a>其他讨论</h2><p>先看如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; mp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">mp.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">mp.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String key: mp.keySet()) &#123;</span><br><span class="line">	<span class="keyword">if</span> (key.equals(<span class="string">&quot;1&quot;</span>)) &#123; <span class="comment">// 或&quot;2&quot;</span></span><br><span class="line">		mp.remove(key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会throw java.util.ConcurrentModificationException<br>原因在于modCount在HashMap调用put和remove的时候都会+1，expectedModCount是在初始化HashIterator的时候取的modCount。在nextEntry()中会有modCount是否等于expectedModCount的判断。<br>这个场景被称为fail-fast。如果有两个线程，一个在遍历，一个在remove，就可能出现脏读和幻读的情况，jdk作者的解决方法是尽快地抛出异常，告诉程序员有多线程的错误（因为知道可能现在出现了并发错误）。<br><br/><br>如何解决这个方法？使用iterator的remove方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator ii = mp.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(ii.hasNext()) &#123;</span><br><span class="line">	String key = (String)ii.next;</span><br><span class="line">	<span class="keyword">if</span> (key.equals(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">		ii.remove(key);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在HashMap的HashIterator中的remove方法中，会给expectedModCount重新赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">	<span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">	Object k = current.key;</span><br><span class="line">	current = <span class="keyword">null</span>;</span><br><span class="line">	HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">	expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<hr>
<p>为什么在重写equals()的时候需要重写hashCode()? (例如判断两个Person对象的时候只比较两个Person的id)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://sihan-wang.github.io/blog/2020/12/10/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Sihan Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarcyCAPU's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/12/10/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-10 21:39:54" itemprop="dateCreated datePublished" datetime="2020-12-10T21:39:54+08:00">2020-12-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sihan Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sihan Wang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
